#ifndef HPP_GIK_WHOLEBODY_TASK_H
#define HPP_GIK_WHOLEBODY_TASK_H

#include  <vector>
#include "tasks/hppGikGenericTask.h"


/**
\brief This is a whole body motion planner. It accepts state constraints and motion constraints for which it is to compute a joints motion.
The motion constraints entered by the user are directly added to the motion plan at the adequate row.
The start time of the planner is 0 seconds, it's the reference for any timings set by the user in the motion and state constraints he enters.
 */
class ChppGikWholeBodyTask: public ChppGikRobotTask
{
public:

    /**
    \brief Constructor
     */
    ChppGikWholeBodyTask(ChppGikStandingRobot* inStandingRobot, double inSamplingPeriod, unsigned int inMaxIterations =1);

    /**
    \brief Get associated robot
    */
    CjrlHumanoidDynamicRobot& robot()const;

    /**
    \brief Add a prioritized state constraint. The state constraint is transformed by the implemented algorithms into motion subtasks which are added to the whole body motion task.
     */
    void addStateConstraint(CjrlGikStateConstraint* inStateConstraint, unsigned int inPriority);

    /**
    \brief Add a prioritized motion constraint. The motion constraint is inserted as-is to the whole body motion task. Simultaneous motion subtasks might be generated by the implemented algorithms.
     */
    void addMotionConstraint(CjrlGikMotionConstraint* inMotionConstraint, unsigned int inPriority);

    /**
    \brief enable stepping if a solution could not be found with the current support polygon.Default value upon construction is True.
    */
    void enableStepping(bool inEnabled);

    /**
    \brief Reset the planner by clearing entered constraints (state and motion)
     */
    void reset();

    /**
    \brief Destructor
     */
    ~ChppGikWholeBodyTask();

protected:
    /**
    \brief Compute a motion complying with the constraints contained in whole body motion task.
     */
    virtual bool algorithmSolve();

    /**
    \brief Clear data related to previous resolution
     */
    void clear();

    /**
    \brief Execute the task resolution plan
     */
    bool executeResolutionPlan();


    /**
    \brief Try to compute a RobotMotion complying with the entered constraints without stepping.
    */
    bool basicSolve();

    /**
    \brief Convert user-entered prioritized constraints to single motion planning tasks with the given start time and duration
    */
    void defaultPlannerTaskMaker(double defaultStartTime,double defaultTaskDuration);

    /**
    \brief Try to compute a RobotMotion complying with the entered constraints by doing a step at the same time.
     */
    bool onestepSolve();

    /**
    \brief Used by oneStep solve to find the projection of the furthest position or tranformation target from the vertical axis between the footprints
    */
    void furthestTargetProjection(double centerX, double centerY, double& outX, double& outY, double& outDistance);

    /**
    \brief Used by onestepSolve().
    Compute footprint candidates for a stepping motion that can help realize the constraints entered by the user. attMaxIterations footprints are computed.
    */
    void createFootprintCandidates(const ChppGikFootprint* startFootprint,double targetX, double targetY, std::vector<ChppGikFootprint*>& inVectorFootprints );

    /**
    \brief Used by onestepSolve().
    Delete footprints created by createFootprintCandidates()
     */
    void deleteFootprintCandidates(std::vector<ChppGikFootprint*>& inVectorFootprints );


    /**
    \brief Determines whether the algorithm can try to plan a step for the robot in order to solve the stack of constraints. Default value upon construction is True.
    */
    bool attEnableStep;
            
    /**
    \brief The solution task plan
     */
    ChppGikGenericTask* attGenericTask;

    /**
    \brief State constraints and priorities entered by the user
     */
    std::vector<ChppGikPrioritizedStateConstraint*> attUserStateTasks;

    /**
    \brief Motion constraints and priorities entered by the user
     */
    std::vector<ChppGikPrioritizedMotionConstraint*> attUserMotionTasks;

    /**
    \brief maximum number of iterations for the embedded algorithm
    */
    unsigned int attMaxIterations;

};

#endif
