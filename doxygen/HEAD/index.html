<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>hpp-gik: GIK START POINT</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('index.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>GIK START POINT </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Oussama Kanoun </dd>
<dd>
</dd></dl>
<h2><a class="anchor" id="sec_intro"></a>
It's time to GIK some linear system's butt.</h2>
<p>So you would like to: </p>
<ul>
<li><a class="el" href="main.html#linSyst_section">Solve a linear system</a> </li>
<li><a class="el" href="main.html#multLinSyst_section">Solve several linear systems in priority order</a> </li>
<li><a class="el" href="main.html#plan1_section">Plan motion for your robot</a> </li>
<li><a class="el" href="main.html#plan2_section">Plan motion for your humanoid robot</a> </li>
<li><a class="el" href="main.html#plan3_section">Obtain humanoid motion without reading all previous sections</a> </li>
<li><a class="el" href="main.html#end_section">Do something else</a></li>
</ul>
<h2><a class="anchor" id="linSyst_section"></a>
Solve a linear system</h2>
<p>Let <img class="formulaInl" alt="$ A \in \Re^{m \times n} $" src="form_10.png"/> and <img class="formulaInl" alt="$ b \in \Re^{m} $" src="form_11.png"/>. Solving linear system <img class="formulaInl" alt="$ \lbrace A x = b \rbrace$" src="form_12.png"/> in <img class="formulaInl" alt="$x$" src="form_13.png"/> consists in finding a solution vector <img class="formulaInl" alt="$ x \in \Re^{n}$" src="form_14.png"/> such as <img class="formulaInl" alt="$ A x = b$" src="form_15.png"/><br/>
</p>
<p>When the linear system is underconstrained, i.e <img class="formulaInl" alt="$ m<n $" src="form_16.png"/>, an infinity of solutions exist. The general form of the solution can be written as: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = x^{*} + N y\]" src="form_17.png"/>
</p>
<p> where: </p>
<ul>
<li><img class="formulaInl" alt="$x^{*}$" src="form_18.png"/> is a solution to the linear system </li>
<li><img class="formulaInl" alt="$N \in \Re^{n \times n}$" src="form_19.png"/> is the projector on the linear subspace <img class="formulaInl" alt="$ {vect(A^{T})}^{\perp}$" src="form_20.png"/> called Nullspace. </li>
<li><img class="formulaInl" alt="$y \in \Re^{n}$" src="form_21.png"/></li>
</ul>
<p>This defines an affine subspace of solutions.<br/>
 The point <img class="formulaInl" alt="$x^{*}$" src="form_18.png"/> can be the minimal norm solution of the system for which we have an analytical expression in case matrix A is of plain rank: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{*} = A^{T} ( A A^{T} )^{-1} b\]" src="form_22.png"/>
</p>
<p> This particular solution is usually called the pseudoinverse or minimal norm solution. There exists a weighted pseudoinverse solution, corresponding to minimization of <img class="formulaInl" alt="$ x^{T} W x$" src="form_23.png"/> where <img class="formulaInl" alt="$W$" src="form_24.png"/> is a positive semi definite matrix. The particular solution is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{*} = W^{-1} A^{T} ( A W^{-1} A^{T} )^{-1} b\]" src="form_25.png"/>
</p>
<p><img class="formulaInl" alt="$W$" src="form_24.png"/> can be used for a variety of effects, like priveledging certain parameters, disactivating others, etc.</p>
<h3><a class="anchor" id="singular_subsec"></a>
Dealing with singular systems</h3>
<p>When A is not of plain rank or is nearly singular, the matrice product <img class="formulaInl" alt="$A A^{T} $" src="form_26.png"/> is singular of nearly singular. A solution that minimizes the cost <img class="formulaInl" alt="$\|A x - b\|$" src="form_27.png"/> can be computed by inverting <img class="formulaInl" alt="$A A^{T} $" src="form_26.png"/> while canceling contribution of low singular values: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{*} = A^{T} ( tsvd(A A^{T}) )^{-1} b\]" src="form_28.png"/>
</p>
<p> where <img class="formulaInl" alt="$tsvd()$" src="form_29.png"/> is the function that enables a singular value <img class="formulaInl" alt="$\sigma$" src="form_30.png"/> for inversion if larger that a given threshold and cancels it otherwise.<br/>
</p>
<p>It is also possible to "damp" the pseudo inverse solution by choosing to compute: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{*} = A^{T} ( A A^{T} + \lambda I )^{-1} b\]" src="form_31.png"/>
</p>
<p> where: </p>
<ul>
<li><img class="formulaInl" alt="$ \lambda $" src="form_32.png"/> is the damping factor </li>
<li><img class="formulaInl" alt="$ I $" src="form_33.png"/> is the identity matrix of size n.</li>
</ul>
<p>This is equivalent to expanding the initial linear system with the following: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \lambda I = 0\]" src="form_34.png"/>
</p>
<p> which tends to attract the solution vector <img class="formulaInl" alt="$ x^{*} $" src="form_35.png"/> to the null vector, depending on the value of <img class="formulaInl" alt="$\lambda$" src="form_36.png"/>.</p>
<h3><a class="anchor" id="solverBasic_section"></a>
Implementation</h3>
<p>The linear system solver in hppGik library is called <a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a>. The constructor <a class="el" href="a00041.html#a1a19213578c9a2560e92066cae87c4ae" title="Constructor.">ChppGikSolverBasic::ChppGikSolverBasic()</a> requires the space dimension <img class="formulaInl" alt="$ n $" src="form_37.png"/>.<br/>
 To construct a <a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> object:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> solver(n);
</pre></div><p>A linear system is provided as an object of class CjrlGikStateConstraint. The method CjrlGikStateConstraint::jacobian() should return matrix <img class="formulaInl" alt="$A \in \Re^{m \times n} $" src="form_38.png"/> and the method CjrlGikStateConstraint::value() should return vector <img class="formulaInl" alt="$b \in \Re^{m}$" src="form_39.png"/>. Let <code>constraint</code> be an object of type CjrlGikStateConstraint. To compute the pseudoinverse solution of the linear system implied by <code>constraint</code> do:</p>
<div class="fragment"><pre class="fragment">solver.solveTask(constraint);
solution = solver.solution();
</pre></div><p>For the weighted pseudoinverse solution, use: </p>
<div class="fragment"><pre class="fragment">solver.weights(weights);
solver.solveTask(constraint);
solution = solver.solution();
</pre></div><p>Note that only diagonal weight matrix W is implemented. The argument of method <a class="el" href="a00041.html#a299e267800c6a4be2874620185fc23aa" title="Set the diagonal weights for the Weighted Pseudoinverse.">ChppGikSolverBasic::weights()</a> is a vector of size <img class="formulaInl" alt="$n$" src="form_40.png"/> used to fill the diagonal of <img class="formulaInl" alt="$W$" src="form_24.png"/>.<br/>
</p>
<p>The default method for dealing with singularity is the SVD thresholding described above. The threshold can be modified through access methods <a class="el" href="a00041.html#aee037224dbfe2977e23d88b86f4de67b" title="Set the minimum singular value.">ChppGikSolverBasic::SVDThreshold()</a>.<br/>
 <br/>
 For damping method, use:</p>
<div class="fragment"><pre class="fragment">solver.solveTask(constraint, lambda);
solution = solver.solution();
</pre></div><p> where parameter lambda stands for damping factor <img class="formulaInl" alt="$\lambda$" src="form_36.png"/>.<br/>
</p>
<p>Any of the previous code can be used to solve a single linear system. To use the same solver object to solve another independant linear system, call <a class="el" href="a00041.html#ae82d4f05e7c0c46b3043f60ac5ba22fb" title="Clear solution.">ChppGikSolverBasic::resetSolution()</a> or <a class="el" href="a00041.html#a299e267800c6a4be2874620185fc23aa" title="Set the diagonal weights for the Weighted Pseudoinverse.">ChppGikSolverBasic::weights()</a> prior to calling <a class="el" href="a00041.html#a5bc1f31d597e6e80fc645da0beddaaa7" title="solve one constraint in the current null space.">ChppGikSolverBasic::solveTask()</a>.<br/>
<br/>
</p>
<p><a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> is also capable of solving a series of linear systems given in decreasing priority order. Next section will present an overview of the theory behind the algorithm, followed by implementation usage info. <br/>
<br/>
</p>
<h2><a class="anchor" id="multLinSyst_section"></a>
Solve several linear systems in priority order</h2>
<h3><a class="anchor" id="algo_subsection"></a>
Algorithm</h3>
<p>Let <img class="formulaInl" alt="$ (E1): (A_{1},b_{1})$" src="form_41.png"/> and <img class="formulaInl" alt="$ (E2): (A_{2},b_{2})$" src="form_42.png"/> denote two linear systems. As seen in the previous section, the general form of <img class="formulaInl" alt="$E1$" src="form_43.png"/> is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = {x_{1}}^{*} + N_1 y\]" src="form_44.png"/>
</p>
<p> We have the analytical expression for <img class="formulaInl" alt="$N_1$" src="form_45.png"/>: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ N_1 = (I - A^{T}(A A^{T})^{-1}A)\]" src="form_46.png"/>
</p>
<p> Solving <img class="formulaInl" alt="$E2$" src="form_47.png"/> in second priority means to compute a solution to <img class="formulaInl" alt="$E2$" src="form_47.png"/> that is within the solutions of <img class="formulaInl" alt="$E1$" src="form_43.png"/>. Therefore <img class="formulaInl" alt="$E2$" src="form_47.png"/> is modified to take into account <img class="formulaInl" alt="$E1$" src="form_43.png"/> priority and becomes: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ N_1 A_2 x = b_2- A_2 {x_{1}}^{*}\]" src="form_48.png"/>
</p>
<p> This system is solved in the same fashion as <img class="formulaInl" alt="$E1$" src="form_43.png"/> to obtain a solution point <img class="formulaInl" alt="${x_{2}}^{*}$" src="form_49.png"/>. The new general form of solution to prioritized systems <img class="formulaInl" alt="$[(E1), (E2)]$" src="form_50.png"/> is : </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = {x_{1}}^{*} + {x_{2}}^{*} + N_1 N_2 z\]" src="form_51.png"/>
</p>
<p>Because <img class="formulaInl" alt="$E2$" src="form_47.png"/> might become singular when projected on <img class="formulaInl" alt="$E1$" src="form_43.png"/>, the methods used to deal with singular cases presented in previous section can still be used here. Then the point <img class="formulaInl" alt="${x_{2}}^{*}$" src="form_49.png"/> would not strictly be solution to <img class="formulaInl" alt="$(E1)$" src="form_52.png"/>, but a least-square- error solution.</p>
<h3><a class="anchor" id="impl2_subsection"></a>
Implementation</h3>
<p><a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> implements prioritized linear system resolution. The systems must be presented one at a time, the solution vector is incremented after each system resolution and the nullspace is updated.<br/>
 To construct a <a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> object: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> solver(n);
</pre></div><p>Let <code>constraint1</code> , <code>constraint2</code> and <code>constraint3</code> be 3 CjrlGikStateConstraint objects. To solve the stack of prioritized systems do:</p>
<div class="fragment"><pre class="fragment">solver.resetSolution();
solver.solveTask(constraint1, 0.0, <span class="keyword">false</span>, <span class="keyword">true</span>);
solver.solveTask(constraint2, 0.0, <span class="keyword">true</span>, <span class="keyword">true</span>);
solver.solveTask(constraint3, 0.0, <span class="keyword">true</span>, <span class="keyword">false</span>);
solution = solver.solution()
</pre></div><p>Second argument <a class="el" href="a00041.html#a5bc1f31d597e6e80fc645da0beddaaa7" title="solve one constraint in the current null space.">ChppGikSolverBasic::solveTask()</a> is the damping factor which can be any positive double value (like in previous section). Argument 3 tells the method whether to project the linear system's matrix <img class="formulaInl" alt="$A$" src="form_53.png"/> with the previous nullspace projector or not. Since <code>constraint1</code> is the first constraint in the stack, there is no need to do so, hence value <code>false</code>. Argument 4 tells the method wether to compute the null space projector <img class="formulaInl" alt="$N_1$" src="form_45.png"/> or not. It is set to <code>true</code> here since it will be used to compute <code>constraint2</code> 's solution. The exact opposite thing happens for last linear system <code>constraint3</code>.<br/>
 In sum, argument 3 an 4 are options to optimize first and last system computation.<br/>
 <a class="el" href="a00041.html#af477a4a469ddb9038eca79d585b59d9d" title="Set active paramters for nest solved task.">ChppGikSolverBasic::setActiveParameters</a> can be used before each <a class="el" href="a00041.html#a5bc1f31d597e6e80fc645da0beddaaa7" title="solve one constraint in the current null space.">ChppGikSolverBasic::solveTask()</a> call to specify the columns of linear system matrix <img class="formulaInl" alt="$A$" src="form_53.png"/> to be used. This can give some computation speedup.<br/>
 <a class="el" href="a00041.html#a299e267800c6a4be2874620185fc23aa" title="Set the diagonal weights for the Weighted Pseudoinverse.">ChppGikSolverBasic::weights()</a> can replace <a class="el" href="a00041.html#ae82d4f05e7c0c46b3043f60ac5ba22fb" title="Clear solution.">ChppGikSolverBasic::resetSolution()</a> in case the weights for the weighted pseudoinverse should be changed. The user can set zero weights for some parameters (for instance when they are not used), leading to faster computation.</p>
<p><br/>
<br/>
 </p>
<h2><a class="anchor" id="plan1_section"></a>
Plan motion for your robot</h2>
<p>Give a look to <a class="el" href="main.html#linSyst_section">Solve a linear system</a> first. So you have a robot, formed of several articulated bodies, for which you want to compute joint motion in order to realize a certain task. Most of the time, the task is naturally expressed in the cartesian space, like position and/or orientation of a body in the robot. The non-linear realationship between body transformations and joint angles is most of the time not invertible, especially when the number of degrees of freedom outnumbers the task dimension. This is where numerical resolution schemes come handy. Here is an outline:</p>
<div class="fragment"><pre class="fragment">WHILE task not achieved DO:
   (1) Compute value (vector) of task
   (2) Compute gradient (jacobian) of task
   (3) Follow task gradient descent to compute a slight change in values of joints
   (4) IF no change in joint values QUIT
   (5) Apply new joint value to robot.
</pre></div><p>Let <img class="formulaInl" alt="$q$" src="form_54.png"/> be the vector of joint values and let <img class="formulaInl" alt="$P(q)$" src="form_55.png"/> be the position of point <img class="formulaInl" alt="$M$" src="form_56.png"/> attached to a body in the robot and expressed in a frame <img class="formulaInl" alt="$R$" src="form_57.png"/> independant of robot motion (for simplicity's sake). Suppose we want point <img class="formulaInl" alt="$M$" src="form_56.png"/> to reach a point whose position is <img class="formulaInl" alt="$T(q)$" src="form_58.png"/> in frame <img class="formulaInl" alt="$R$" src="form_57.png"/>. The above code becomes:</p>
<div class="fragment"><pre class="fragment">WHILE P(q) - T(q) != 0 DO:
   (1) Value             V = eval(T(q) - P(q))
   (2) Jacobian          J = d (P - T) / d q 
   (3) Slight change     dq = r * pseudoinverse(J) * V
   (4) IF dq = 0 QUIT
   (5) q = q + dq
</pre></div><p>where <code>r</code> is a positive real used to scale the value.<br/>
 The joint update computed at step (3) is the solution to the linear system: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {{\partial (P - T)} \over {\partial {q}}}(q) \delta q = r V \]" src="form_59.png"/>
</p>
<p>If <code>r</code> is controlled properly through iterations, the above algorithm yields a smooth motion. The achievement of position <img class="formulaInl" alt="$T$" src="form_60.png"/> is not guaranteed because the linear system might become singular after a few iterations, even from start. In that case the algorithm is said to be trapped in a local minimum and it cannot achieve any better.<br/>
</p>
<h3><a class="anchor" id="impl3_subsection"></a>
Implementation</h3>
<p>Given the tasks, the user should implement CjrlGikStateConstraint objects that compute the jacobians and values correponding to the respective tasks. To solve the linear systems implied by step (3) <a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a> can be used.<br/>
 However, a problem arises for a robot: joint limits. Joint limits are inequality constraints on the joint values that must constantly be verified. <a class="el" href="a00040.html" title="Compute the joints updates for a hierarchy of simultaneous tasks.">ChppGikSolver</a> is a prioritized linear system solver based on <a class="el" href="a00041.html" title="This is a prioritized inverse kinematics solver.">ChppGikSolverBasic</a>, it uses a ChppGikBounder object to enforce joint limits. See these objects' documentation for more details.<br/>
</p>
<p>First construct a solver and pile up CjrlGikStateConstraint objects in a priority-decreasing vector:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00040.html" title="Compute the joints updates for a hierarchy of simultaneous tasks.">ChppGikSolver</a> solver(robot);
std::vector&lt;CjrlGikStateConstraint*&gt; stack;
stack.push_back(highest_priority_constraint);
stack.push_back(mid_priority_constraint);
stack.push_back(low_priority_constraint);
</pre></div><p>This code corresponds to a single iteration of the above algorithm (but with several prioritized tasks): </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Steps (1) and (2)</span>
<span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt; stack.size();i++)
{
    stack[i]-&gt;computeValue();
    stack[i]-&gt;computeJacobian();
}
<span class="comment">//Step (3)</span>
solver.solve( stack );
<span class="comment">//Step (4)</span>
<span class="keywordflow">if</span> (norm_2(solver.solution()) &lt; 1e-5)
    <span class="keywordflow">return</span>;
<span class="comment">//Step (5)</span>
<span class="comment">//Compute new configuration/velocity/acceleration vectors of robot and apply them</span>
</pre></div><p>There is a variation of <a class="el" href="a00040.html#acd5da5ecfa3c89d7ca1f819793aafa68" title="Compute a solution to the entered vector of linear systems.">ChppGikSolver::solve()</a> to add damping factors. See documentation for details.<br/>
</p>
<p>See <a class="el" href="a00002.html">Example I</a> for a source code using <a class="el" href="a00040.html" title="Compute the joints updates for a hierarchy of simultaneous tasks.">ChppGikSolver</a>.</p>
<p><br/>
<br/>
 </p>
<h2><a class="anchor" id="plan2_section"></a>
Plan motion for your humanoid robot</h2>
<p>This section is merely about drawing the user's attention to humanoid's stability issue.<br/>
 As a matter of fact, to reach something with the right hand, and supposing the humanoid is standing upon a flat ground, it needs to move while keeping its Zero Momentum Point inside its support polygon. There is NOTHING implemented in this library that provides such a guarantee. However, if the planned motion is smooth enough (does not necessarily mean slow), then keeping the center of mass's projection inside the support polygon should be enough to achieve a stable reaching motion.<br/>
<br/>
 See <a class="el" href="a00002.html">Example I</a> for a code where center of mass and feet constraints are added to maintain stability while reaching.</p>
<p><br/>
<br/>
 </p>
<h2><a class="anchor" id="plan3_section"></a>
Obtain humanoid motion without reading all previous sections</h2>
<p>Well, this is no joke, you will be able to compute all kinds of motion just reading this section. At the expense of flexibility, of course. The API shown in previous sections would be "low-level" compared to the one shown here.<br/>
 Attention is focused on <a class="el" href="a00012.html" title="This object produces whole body joint motion based on entered &quot;elements&quot;.These elements are cartesian motion planners of class ChppGikPrioritizedMotion or class ChppGikLocomotionElement.">ChppGikGenericTask</a> class. Objects of this class define a time scale <img class="formulaInl" alt="$[0,+\inf[$" src="form_61.png"/> on which the user schedules finite-time motions.<br/>
 A motion is either a <a class="el" href="a00034.html" title="Store a pointer to a CjrlGikMotionConstraint and additional information.">ChppGikPrioritizedMotion</a> or a <a class="el" href="a00019.html" title="A locomotion element is a motion planning task that produces threes motion chunks: a 2D Zero Momentum...">ChppGikLocomotionElement</a>.<br/>
 <a class="el" href="a00034.html" title="Store a pointer to a CjrlGikMotionConstraint and additional information.">ChppGikPrioritizedMotion</a> motions are defined by a desired constraint of class <a class="el" href="a00051.html">ChppGikVectorizableConstraint</a>, a time frame (i.e a start time and end time), a priority integer (the higher the integer the lower the priority) and a "mask vector" that defines active and inactive joints for the accomplishment of the motion.<br/>
 <a class="el" href="a00019.html" title="A locomotion element is a motion planning task that produces threes motion chunks: a 2D Zero Momentum...">ChppGikLocomotionElement</a> are special motions that affect feet and center of mass. <a class="el" href="a00045.html" title="This is motion planner for a step This is a sequence ChppGikZMPshiftElement-ChppGikFootDisplaceElemen...">ChppGikStepElement</a> is an example of <a class="el" href="a00019.html" title="A locomotion element is a motion planning task that produces threes motion chunks: a 2D Zero Momentum...">ChppGikLocomotionElement</a> that an be used to plan stepping motion for the humanoid robot.<br/>
 <a class="el" href="a00012.html" title="This object produces whole body joint motion based on entered &quot;elements&quot;.These elements are cartesian motion planners of class ChppGikPrioritizedMotion or class ChppGikLocomotionElement.">ChppGikGenericTask</a> object takes care of stability of the robot. For example, to move the right hand from its current position to a given position, the user need not specify feet and center of mass tasks.<br/>
 The output of <a class="el" href="a00012.html" title="This object produces whole body joint motion based on entered &quot;elements&quot;.These elements are cartesian motion planners of class ChppGikPrioritizedMotion or class ChppGikLocomotionElement.">ChppGikGenericTask</a> is a stable <a class="el" href="a00055.html" title="Defines the motion of a robot along time.">ChppRobotMotion</a>.<br/>
 Further details can be found in <a class="el" href="a00012.html" title="This object produces whole body joint motion based on entered &quot;elements&quot;.These elements are cartesian motion planners of class ChppGikPrioritizedMotion or class ChppGikLocomotionElement.">ChppGikGenericTask</a> documentation. Let us just give usage outline :<br/>
<br/>
</p>
<p>Prepare a robot and a generic task: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Supposing object &quot;robot&quot; is of class CjrlHumanoidDynamicRobot, and is in double support configuration:</span>
<a class="code" href="a00043.html" title="Wrapper for a jrlHumanoidDynamicRobot, support polygon and related information.">ChppGikStandingRobot</a> standingRobot(robot);
<span class="keywordtype">double</span> samplingPeriod = 5e-3;
<a class="code" href="a00012.html" title="This object produces whole body joint motion based on entered &amp;quot;elements&amp;quot;.These elements are cartesian motion planners of class ChppGikPrioritizedMotion or class ChppGikLocomotionElement.">ChppGikGenericTask</a> genericTask(standingRobot, samplingPeriod);
</pre></div><p>Schedule prioritized motion and locomotion objects in generic task: </p>
<div class="fragment"><pre class="fragment">genericTask.addElement(motion1);
genericTask.addElement(step1);
</pre></div><p>Solve and retrieve solution if successful: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> ok = genericTask.solve();
<span class="keywordflow">if</span> (ok)
    motion = genericTask.solutionMotion();
</pre></div><p><br/>
 Have a look at <a class="el" href="a00112.html">Dedicated Tasks</a> for ready-to-use motion planners built upon <a class="el" href="a00012.html" title="This object produces whole body joint motion based on entered &quot;elements&quot;.These elements are cartesian motion planners of class ChppGikPrioritizedMotion or class ChppGikLocomotionElement.">ChppGikGenericTask</a>.</p>
<p><br/>
<br/>
 </p>
<h2><a class="anchor" id="end_section"></a>
Do something else</h2>
<p>Perfectly understandable. </p>
</div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</body>
</html>
